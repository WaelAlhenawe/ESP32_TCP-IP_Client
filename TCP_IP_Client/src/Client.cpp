#include <Client.h>


// The keys are generated by https://csfieldguide.org.nz/en/interactives/rsa-key-generator/

static uint8_t client_public_key[RSA_SIZE] = {
    0xDB, 0x44, 0xDD, 0xA4, 0xB7, 0xAB, 0x9D, 0x86, 0x2B, 0xBD, 0xC1, 0xFD, 0x67, 0xC9, 0x0B, 0xAF,
    0x05, 0x76, 0x3E, 0x4E, 0xD3, 0xD1, 0xDF, 0x9B, 0x7A, 0x75, 0x6E, 0x4C, 0x5F, 0x63, 0x63, 0x75};
static uint8_t client_private_key[RSA_SIZE] = {
    0x5B, 0xF4, 0x39, 0x6F, 0x46, 0x87, 0x75, 0xFC, 0x3A, 0x83, 0xCD, 0xC2, 0xD3, 0xAF, 0x80, 0x72,
    0x12, 0x98, 0x99, 0x0E, 0x0F, 0x43, 0xA2, 0x7B, 0x47, 0xB1, 0x3C, 0x23, 0xC9, 0x99, 0x64, 0x81};
static uint8_t public_key_server[RSA_SIZE] = {
    0xC3, 0xA5, 0x4E, 0x87, 0xAD, 0xC6, 0xA4, 0x02, 0x11, 0x0B, 0xF2, 0x75, 0xE3, 0xB6, 0x6D, 0xE6,
    0x55, 0xA0, 0x17, 0x60, 0x16, 0xC2, 0x12, 0x58, 0xA9, 0xC6, 0xF5, 0x91, 0xCD, 0xB7, 0xA7, 0xA9};

static uint8_t auth_key[RSA_BLOCK_SIZE] = "kp2-5v8/B?E(H+VmY3wA";


// To print data in hex
void print_data(const uint8_t *data, uint8_t size)
{
  for (uint8_t i = 0; i < size; i++)
  {
    Serial.printf("%02X ", data[i]);
  }
  Serial.println();
}

// Menu choice
char services_menu()
{
  bool menu_apper = true, ok = true, get_it = false;
  char chr = '0';

  while (ok)
  {
    while (menu_apper)
    {
      menu_apper = false;
      get_it = false;

      Serial.println("------------------------------");
      Serial.println("Please Choose Type Of Service.");
      Serial.println("------------------------------");
      Serial.println("(0) For Authentication.");
      Serial.println("(1) For Set Light ON.");
      Serial.println("(2) For Set Light OFF.");
      Serial.println("(3) For Get Light Status.");
      Serial.println("(4) For Get Server Temperature.");
      Serial.println("(5) For End Session.");
      Serial.print("Your Choice: ");
    }

    while (!get_it)
    {
      if (Serial.available())
      {
        chr = Serial.read();

        Serial.println(chr);

        if (chr == '0' || chr == '1' || chr == '2' || chr == '3' || chr == '4' || chr == '5')
        {
          get_it = true;
          ok = false;
        }
        else
        {
          Serial.println("PLEASE ENTER RIGHT CHOICE");
          get_it = true;
          menu_apper = true;
        }
      }
    }
  }
  return chr;
}

// Fuction handling the decryption based on AES/RSA
response_info message_parsing(response_info old_decrypted_details, uint8_t mes_len, uint8_t *message)
{
#ifdef DEVELOPMENT
  Serial.println("I AM ON MESSAGE PARSING: ");
  Serial.printf("\nMes_Len is: %d\n", mes_len);
  Serial.print("The Whole Message is: ");
  print_data(message, mes_len);

#endif
  response_info decrypted_details = old_decrypted_details;
  uint8_t decrypting_size, *decrypted_data;

  if (mes_len == RSA_MES_SIZE)
  {
    uint8_t temp_aes_key[AES_KEY_SIZE]={};
    decrypting_size = RSA_BLOCK_SIZE;
    decrypted_data = (uint8_t *)malloc(decrypting_size);
    rsa_private_decrypt(message, client_public_key, client_private_key, decrypted_data);
    memcpy(decrypted_details.session_Id, decrypted_data, SESSION_ID_SIZE);
    memcpy(temp_aes_key, &*decrypted_data + SESSION_ID_SIZE, AES_KEY_SIZE);
    aes128_init_key(temp_aes_key);
#ifdef DEVELOPMENT
    Serial.print("Session ID is: ");
    print_data(decrypted_details.session_Id, SESSION_ID_SIZE);
    Serial.print("AES key is: ");
    print_data(temp_aes_key, AES_KEY_SIZE);
#endif
    free(decrypted_data);
  }
  if (mes_len == REQUEST_MES_SIZE)
  {
    decrypting_size = AES_BLOCK_SIZE;
    decrypted_data = (uint8_t *)malloc(decrypting_size);
    aes128_decrypt(message, decrypted_data);
    decrypted_details.type = (receiving_types)decrypted_data[0];
    memcpy(decrypted_details.message, &*decrypted_data + 1, AES_BLOCK_SIZE);

#ifdef DEVELOPMENT
    Serial.printf("\nResponse type is: %d\n", (int)decrypted_details.type);
    Serial.printf("\nResponse Message is: %s\n", decrypted_details.message);
#endif
    free(decrypted_data);
  }
  return decrypted_details;
}

// Hash checking
bool check_hash(uint8_t mes_len, uint8_t *the_whole_message)
{
#ifdef DEVELOPMENT
    Serial.println("\n//.........................I AM IN HASH CHECK.........................//\n");
#endif

    uint8_t the_mes[mes_len - HASH_SIZE], res_hash[HASH_SIZE], temp_hash[HASH_SIZE];

    memcpy(the_mes, the_whole_message, mes_len - HASH_SIZE);

    memcpy(res_hash, &*the_whole_message + (mes_len - HASH_SIZE), HASH_SIZE);

    sha1(the_mes, mes_len - HASH_SIZE, temp_hash);
#ifdef DEVELOPMENT
    Serial.print("Received Hash is:   ");
    print_data(res_hash, HASH_SIZE);
    Serial.print("Calculated Hash is: ");
    print_data(temp_hash, HASH_SIZE);
#endif
    if (!memcmp(temp_hash, res_hash, HASH_SIZE))
    {
        return true;
        ;
    }
    else
    {
        return false;
    }
}

// Building the request message to the server after authentication
void build_request(const uint8_t *session_id, sending_types request, char *buffer)
{
  uint8_t hash[HASH_SIZE] = {};
  Serial.println("I AM ON BUILD : ");
  uint8_t *full_mes, *encrypted_mes;
  full_mes = (uint8_t *)malloc(SESSION_ID_SIZE + 1);
  encrypted_mes = (uint8_t *)malloc(AES_CIPHER_SIZE);
  Serial.printf("ID is:");
  print_data(session_id, SESSION_ID_SIZE);
  memcpy_P(full_mes, session_id, SESSION_ID_SIZE);
  full_mes[SESSION_ID_SIZE] = request;

  aes128_encrypt(full_mes, SESSION_ID_SIZE + 1, encrypted_mes);
  Serial.printf("Encrypted Mes is:");
  print_data(encrypted_mes, AES_CIPHER_SIZE);
  sha1(encrypted_mes, AES_CIPHER_SIZE, hash);

#ifdef DEVELOPMENT
  Serial.print("Hash builded is: ");
  print_data(hash, sizeof(hash));
#endif

  memcpy(buffer, encrypted_mes, AES_CIPHER_SIZE);
  memcpy(buffer + AES_CIPHER_SIZE, hash, HASH_SIZE);
  free(full_mes);
  free(encrypted_mes);
}

// Building the message for authentication
void authorization(uint8_t * buffer)
{
  uint8_t counter = 0U;  
  uint8_t auth_hash[HASH_SIZE] = {};
  sha1(auth_key, RSA_BLOCK_SIZE, auth_hash);
  Serial.print("First hash is: ");
  print_data((uint8_t *)auth_hash, HASH_SIZE);

  uint8_t sign_auth[RSA_SIZE] = {};
  rsa_private_encrypt(auth_hash, HASH_SIZE, client_public_key, client_private_key, sign_auth);
  Serial.println("Sign  is: ");
  print_data(sign_auth, RSA_SIZE);
  uint8_t sign_first_part[RSA_BLOCK_SIZE] = {};
  uint8_t sign_second_part[RSA_SIZE - RSA_BLOCK_SIZE] = {};

  for (uint8_t i = 0; i < RSA_BLOCK_SIZE; i++)
  {
    sign_first_part[i] = sign_auth[i];
  }
  for (uint8_t i = RSA_BLOCK_SIZE; i < RSA_SIZE; i++)
  {
    sign_second_part[i - RSA_BLOCK_SIZE] = sign_auth[i];
  }

  Serial.println("Second part is: ");
  print_data(sign_second_part, RSA_SIZE - RSA_BLOCK_SIZE);
  uint8_t en_sign_first_part[RSA_SIZE] = {};
  uint8_t en_sign_second_part[RSA_SIZE] = {};

  rsa_public_encrypt(sign_first_part, RSA_BLOCK_SIZE, public_key_server, en_sign_first_part);
  rsa_public_encrypt(sign_second_part, RSA_SIZE - RSA_BLOCK_SIZE, public_key_server, en_sign_second_part);

  for (counter = 0; counter < RSA_SIZE; counter++)
  {
    buffer[counter] = en_sign_first_part[counter];
  }

  for (; counter < (RSA_SIZE * 2); counter++)
  {
    buffer[counter] = en_sign_second_part[counter - RSA_SIZE];
  }

  uint8_t auth_hash_hash[HASH_SIZE] = {};
  sha1(buffer, (RSA_SIZE * 2), auth_hash_hash);
  for (counter = counter; counter < (RSA_SIZE * 2) + HASH_SIZE; counter++)
  {
    buffer[counter] = auth_hash_hash[counter - (RSA_SIZE * 2)];
  }
  Serial.print("The whole message is: ");
  print_data(buffer, counter);
}

// Function to get the length of the received buffer
uint8_t check_mes_len(uint8_t *mes)
{
#ifdef DEVELOPMENT
    Serial.println("\n//...................I AM IN CHECKING MESSAGE LENGHT..................//\n");
#endif
  uint8_t mes_len = 0, counter = 0;

  for (uint8_t i = 0; i < BUFFER_SIZE; i++)
  {
    if (mes[i] == (0x00))
    {
      if (counter < 3)
      {
        if (counter == 0)
        {
          mes_len = i;
        }
        counter++;
      }
      else
      {
        break;
      }
    }
    else
    {
      counter = 0;
    }
  }
#ifdef DEVELOPMENT
    Serial.printf("Message Lenght is: %d\n", (int) mes_len);
#endif
  return mes_len;
}
