#include <WiFi.h>
#include <Arduino.h>
#include <esp32-hal.h>
#include <IPAddress.h>
#include <WiFiClient.h>

#include <RSA.h>
#include <SHA1.h>
#include <AES128.h>

// #define SSID "YA-LOCAL"
// #define PASSWORD "utbildning2020"

#define SSID "Telia-ED8AC9"
#define PASSWORD "05162D814F"

#define PORT (12345U)
#define SERVER "192.168.1.165"

#define LENGTH (16U)
#define HASH_SIZE (20U)
#define BUFFER_SIZE (128U)
#define SESSION_ID_SIZE (4U)
#define REQUEST_BLOCK_SIZE (2U)

// The keys and the exponent are generated by https://csfieldguide.org.nz/en/interactives/rsa-key-generator/

//static uint8_t exponent[] = {0x00, 0x01, 0x00, 0x01};
static uint8_t client_public_key[RSA_SIZE] = {
    0xDB, 0x44, 0xDD, 0xA4, 0xB7, 0xAB, 0x9D, 0x86, 0x2B, 0xBD, 0xC1, 0xFD, 0x67, 0xC9, 0x0B, 0xAF,
    0x05, 0x76, 0x3E, 0x4E, 0xD3, 0xD1, 0xDF, 0x9B, 0x7A, 0x75, 0x6E, 0x4C, 0x5F, 0x63, 0x63, 0x75};
static uint8_t client_private_key[RSA_SIZE] = {
    0x5B, 0xF4, 0x39, 0x6F, 0x46, 0x87, 0x75, 0xFC, 0x3A, 0x83, 0xCD, 0xC2, 0xD3, 0xAF, 0x80, 0x72,
    0x12, 0x98, 0x99, 0x0E, 0x0F, 0x43, 0xA2, 0x7B, 0x47, 0xB1, 0x3C, 0x23, 0xC9, 0x99, 0x64, 0x81};
static uint8_t public_key_server[RSA_SIZE] = {
    0xC3, 0xA5, 0x4E, 0x87, 0xAD, 0xC6, 0xA4, 0x02, 0x11, 0x0B, 0xF2, 0x75, 0xE3, 0xB6, 0x6D, 0xE6,
    0x55, 0xA0, 0x17, 0x60, 0x16, 0xC2, 0x12, 0x58, 0xA9, 0xC6, 0xF5, 0x91, 0xCD, 0xB7, 0xA7, 0xA9};
// static uint8_t private_key_server[RSA_SIZE] ={
// 0x56, 0x29, 0x30, 0xE2, 0x73, 0xD7, 0x6D, 0x57, 0x33, 0xA6, 0xAD, 0x4A, 0xD9, 0xD3, 0xF7, 0xA5,
// 0x98, 0xF3, 0xFA, 0x07, 0x64, 0x7D, 0xE5, 0xE4, 0x4B, 0x13, 0x5C, 0x90, 0x38, 0xF4, 0x3B, 0x59 };

static bool status = false;

enum request_types
{
  LED_ON = 1,
  LED_OFF,
  TEMPERATURE
};

enum error_typs
{
  NOT_RESEIVED = 1,
  NOT_AUTH,
  SESSION_END,
};

struct message_info
{
  uint8_t message[RSA_SIZE] = {};
  uint8_t hash_value[HASH_SIZE] = {};
};

struct response_info
{
  uint8_t session_Id[SESSION_ID_SIZE] = {};
  uint8_t aes_key[AES_BLOCK_SIZE] = {};
};

static void print_data(const uint8_t *data, uint8_t size)
{
  for (uint8_t i = 0; i < size; i++)
  {
    Serial.printf("%02X ", data[i]);
  }
  Serial.println();
}

static void services_menu(uint8_t *massage)
{
  bool menu_apper = true, flag = true, finish = false;
  while (flag)
  {

    while (menu_apper)
    {
      menu_apper = false;

      Serial.println("------------------------------");
      Serial.println("Please Choose Type Of Service.");
      Serial.println("------------------------------");
      Serial.println("(1) For Set Light ON.");
      Serial.println("(2) For Set Light OFF.");
      Serial.println("(3) For Get Server Temperature.");
      Serial.println("(5) For End Session.");

      Serial.print("Your Choice: ");
    }

    while (!finish)
    {
      if (Serial.available())
      {

        char chr = Serial.read();
        if (chr == '\r')
        {
          chr = Serial.read();
        }

        if (chr && chr != '\n')
        {
          Serial.println(chr);
          massage[0] = (uint8_t)chr;
          Serial.println(massage[0]);
          massage[1] = (uint8_t)'\n';
          Serial.println(massage[1]);

          finish = true;
          flag = false;
        }
      }
    }
  }
  Serial.println("After Serial Available");

  if (!(massage[0] > 0 + '0' && massage[0] < 6 + '0'))
  {
    menu_apper = true;
    const char wrong_input[26] = "PLEASE ENTER RIGHT CHOICE";
    for (int i = 0; i < strlen(wrong_input); i++)
    {
      Serial.printf("%c", wrong_input[i]);
      delay(500);
    }
    Serial.println();
  }
  else
  {
    flag = false;
  }
}

//static uint8_t client_public_key[RSA_SIZE] ={};
//static uint8_t client_private_key[RSA_SIZE] ={};
static WiFiClient client;
static uint8_t tx_counter = 0U;
static char tx_buffer[BUFFER_SIZE] = {};
static message_info message_details;
static response_info response_details;
static uint8_t session_Id[SESSION_ID_SIZE] = {};
const uint8_t *key = {};

static response_info response_parsing(uint8_t *message)
{
  Serial.println("I AM ON RESPONSE PARSING: ");
  Serial.printf("Recived message lenght is = %d \n", strlen((char *)message));

  response_info temp = {};

  for (uint8_t i = 0; i < SESSION_ID_SIZE; i++)
  {
    temp.session_Id[i] = message[i];
  }
  Serial.println("Session ID is: ");
  print_data(temp.session_Id, sizeof(temp.session_Id));

  for (uint8_t i = SESSION_ID_SIZE; i < SESSION_ID_SIZE + AES_BLOCK_SIZE; i++)
  {
    temp.aes_key[i - SESSION_ID_SIZE] = message[i];
  }
  Serial.println("Reqest is: ");
  print_data(temp.aes_key, sizeof(temp.aes_key));

  return temp;
}

static message_info message_parsing(uint8_t *message)
{
  Serial.println("I AM ON MESSAGE PARSING: ");
  Serial.printf("Recived message lenght is = %d \n", strlen((char *)message));

  message_info temp = {};

  if (strlen((char *)message) == 52)
  {
    for (uint8_t i = 0; i < RSA_SIZE; i++)
    {
      temp.message[i] = message[i];
    }
    Serial.println("Message is: ");
    print_data(temp.message, sizeof(temp.message));

    for (uint8_t i = RSA_SIZE; i < RSA_SIZE + HASH_SIZE; i++)
    {
      temp.hash_value[i - RSA_SIZE] = message[i];
    }
    Serial.println("Hsah is: ");
    print_data(temp.hash_value, sizeof(temp.hash_value));
  }
  if (strlen((char *)message) == 36)
  {
    for (uint8_t i = 0; i < AES_CIPHER_SIZE; i++)
    {
      temp.message[i] = message[i];
    }
    Serial.println("Message is: ");
    print_data(temp.message, sizeof(temp.message));

    for (uint8_t i = AES_CIPHER_SIZE; i < AES_CIPHER_SIZE + HASH_SIZE; i++)
    {
      temp.hash_value[i - AES_CIPHER_SIZE] = message[i];
    }
    Serial.println("Hsah is: ");
    print_data(temp.hash_value, sizeof(temp.hash_value));
  }
  return temp;
}

static bool check_hash(uint8_t *mes, const uint8_t *hash_res)
{
  Serial.println("I AM ON CHECK HASH: ");

  bool flag = true;
  uint8_t temp_hash[HASH_SIZE] = {};
  sha1(mes, RSA_SIZE, temp_hash);

  Serial.print("New hash is: ");
  print_data(temp_hash, HASH_SIZE);

  Serial.print("Old hash is: ");
  print_data(hash_res, HASH_SIZE);

  for (int i = 0; i < HASH_SIZE; i++)
  {
    if (!(hash_res[i] == temp_hash[i]))
    {
      flag = false;
      break;
    }
  }
  delay(10000);
  return flag;
}

static void build_request(uint8_t *session_Id, uint8_t *data, uint8_t data_size, char *buffer)
{
  uint8_t hash[HASH_SIZE] = {};
  Serial.println("I AM ON BUILD : ");

  // Debug
  Serial.print("data message: ");
  Serial.println((char *)data);
  //Serial.println(data_size);
  uint8_t temp[data_size] = {};
  for (uint8_t i = 0; i < SESSION_ID_SIZE; i++)
  {
    temp[i] = session_Id[i];
  }
  for (uint8_t i = SESSION_ID_SIZE; i < SESSION_ID_SIZE + REQUEST_BLOCK_SIZE; i++)
  {
    temp[i] = data[i - SESSION_ID_SIZE];
  }
  uint8_t encrypted[AES_CIPHER_SIZE] = {};
  aes128_encrypt(temp, data_size, encrypted);

  sha1(encrypted, AES_CIPHER_SIZE, hash);

  // Debug
  Serial.print("Hash builded is: ");
  print_data(hash, sizeof(hash));
  uint8_t x = 0U;
  for (uint8_t x = 0; x < data_size; x++)
  {
    buffer[x] = encrypted[x];
  }
  for (uint8_t x = data_size; x < data_size + HASH_SIZE; x++)
  {
    buffer[x] = hash[x - data_size];
  }
  buffer[x] = '\0';
}

/*// Set your Static IP address

IPAddress local_IP(172, 31, 31, 59);
// Set your Gateway IP address
//IPAddress gateway(172, 31, 1, 1);

//IPAddress subnet(255, 255, 0, 0);
// Set your Gateway IP address
IPAddress gateway(172, 31, 31, 1);

IPAddress subnet(255, 255, 0, 0);
IPAddress primaryDNS(8, 8, 8, 8);   //optional
IPAddress secondaryDNS(8, 8, 4, 4); //optional
//extern "C" // Extern C is used when we are using a funtion written in "C" language in a C++ code.
//{
//uint8_t temprature_sens_read(); // This function is written in C language
//}

//uint8_t temprature_sens_read();
*/
uint8_t buffer_size;
void setup()
{
  /*   // Configures static IP address
   if (!WiFi.config(local_IP, gateway, subnet, primaryDNS, secondaryDNS)) {
     Serial.println("STA Failed to configure");
   }*/

  Serial.begin(9600);
  while (!Serial)
  {
    delay(100);
  }
  Serial.print("\nIP Address: ");

  WiFi.begin(SSID, PASSWORD);

  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    Serial.print(".");
  }

  Serial.print("\nIP Address: ");
  Serial.println(WiFi.localIP());
}

void loop()
{
  //rsa_generate_keys(client_public_key, client_private_key);

  uint8_t auth_key[RSA_BLOCK_SIZE] = "kp2-5v8/B?E(H+VmY3wA";
  // if(!status){
  //   buffer_size = 84U;
  // }
  // else{
  //   buffer_size = 36U;
  // }
  //char tx_buffer[buffer_size] = {};

  if (!status)
  {

    uint8_t auth_hash[HASH_SIZE] = {};
    sha1(auth_key, RSA_BLOCK_SIZE, auth_hash);
    Serial.print("First hash is: ");
    print_data((uint8_t *)auth_hash, HASH_SIZE);

    uint8_t sign_auth[RSA_SIZE] = {};
    rsa_private_encrypt(auth_hash, HASH_SIZE, client_public_key, client_private_key, sign_auth);

    uint8_t sign_first_part[RSA_BLOCK_SIZE] = {};
    uint8_t sign_second_part[RSA_BLOCK_SIZE] = {};

    for (uint8_t i = 0; i < RSA_BLOCK_SIZE; i++)
    {
      sign_first_part[i] = sign_auth[i];
    }
    for (uint8_t i = RSA_BLOCK_SIZE; i < RSA_SIZE; i++)
    {
      sign_second_part[i - RSA_BLOCK_SIZE] = sign_auth[RSA_BLOCK_SIZE];
    }
    
    uint8_t en_sign_first_part[RSA_SIZE] = {};
    uint8_t en_sign_second_part[RSA_SIZE] = {};

    rsa_public_encrypt(sign_first_part, RSA_BLOCK_SIZE, public_key_server, en_sign_first_part);
    rsa_public_encrypt(sign_first_part, RSA_BLOCK_SIZE, public_key_server, en_sign_first_part);

    for (tx_counter = 0; tx_counter < RSA_SIZE; tx_counter++)
    {
      tx_buffer[tx_counter] = en_sign_first_part[tx_counter];
    }
    for (tx_counter = tx_counter; tx_counter < (RSA_SIZE * 2); tx_counter++)
    {
      tx_buffer[tx_counter] = en_sign_second_part[tx_counter - RSA_SIZE];
    }

    uint8_t auth_hash_hash[HASH_SIZE] = {};
    sha1((uint8_t*) tx_buffer, (RSA_SIZE * 2) , auth_hash_hash);
    for (tx_counter = tx_counter; tx_counter < (RSA_SIZE *2) + HASH_SIZE; tx_counter++)
    {
      tx_buffer[tx_counter] = auth_hash_hash[tx_counter - (RSA_SIZE*2)];
    }

    tx_buffer[tx_counter] = '\0';

    Serial.print("The whole message is: ");
    print_data((uint8_t *)tx_buffer, tx_counter);
  }

  if (status)
  {

    Serial.println("I am on REQUEST");

    uint8_t choice[2] = {};
    services_menu(choice);
    Serial.println("Menu Passed");
    build_request(session_Id, choice, sizeof(choice) + SESSION_ID_SIZE, tx_buffer);
  }

  if (tx_buffer[tx_counter] == '\0')
  {
    Serial.println("I am here");

    client.connect(SERVER, PORT);

    if (client.connected())
    {
      Serial.println("I am here2");

      if (client.write(tx_buffer) == strlen(tx_buffer))
      {

        Serial.println("I am here3");

        uint8_t rx_buffer[buffer_size] = {};

        while (!strlen((char *)rx_buffer))
        {
          if (client.connected())
          {

            client.read((uint8_t *)rx_buffer, (size_t)sizeof(rx_buffer));
            uint8_t encrypted_massage_size;
            uint8_t decrypted_massage_size;

            // Error Receiving 1
            if (strlen((char *)rx_buffer))
            {
              message_info message_details;
              response_info request_details;

              Serial.println("Lenght of HASH out Check");
              Serial.println(strlen((char *)message_parsing(rx_buffer).hash_value));

              if (strlen((char *)message_parsing(rx_buffer).hash_value) == HASH_SIZE)
              {
                message_details = message_parsing(rx_buffer);
                Serial.println("Passed Parsing");

                if (strlen((char *)message_parsing(rx_buffer).message) == RSA_SIZE)
                {
                  encrypted_massage_size = RSA_SIZE;
                  decrypted_massage_size = RSA_BLOCK_SIZE;
                }
                else
                {
                  encrypted_massage_size = AES_CIPHER_SIZE;
                  decrypted_massage_size = AES_BLOCK_SIZE;
                }

                uint8_t decrypt[decrypted_massage_size] = {};
                if (check_hash(message_details.message, message_details.hash_value))
                {
                  if (encrypted_massage_size == RSA_SIZE)
                  {
                    Serial.print("Will decrypt By RSA:");
                    rsa_public_decrypt(message_details.message, public_key_server, decrypt);
                    response_details = response_parsing(decrypt);
                    key = aes128_init_key(response_details.aes_key);
                    memcpy(session_Id, response_details.session_Id, SESSION_ID_SIZE);
                    Serial.print("AES Key: ");
                    print_data(key, AES_KEY_SIZE);
                    Serial.print("Session Id Is: ");
                    print_data(session_Id, SESSION_ID_SIZE);
                    status = true;
                  }
                  else
                  {
                    Serial.print("Will decrypt By AES:");
                    aes128_decrypt(message_details.message, decrypt);
                    message_details = message_parsing(decrypt);

                    switch ((error_typs)decrypt[0])
                    {
                    case (error_typs(NOT_RESEIVED)):
                    {
                      Serial.print("The encrypted res massage is: ");

                      Serial.println((char *)decrypt);

                      break;
                    }
                    case (error_typs(NOT_AUTH)):

                      Serial.print("Auth Error: ");

                      Serial.println((char *)decrypt);
                      status = false;

                      break;
                    case (error_typs(SESSION_END)):
                    {

                      Serial.print("Seesion END: ");

                      Serial.println((char *)decrypt);
                      status = false;

                      break;
                    default:
                      Serial.print("The massage is: ");

                      Serial.println((char *)decrypt);
                      break;
                    }
                    }
                  }
                }
                else
                {

                  client.stop();
                  client.connect(SERVER, PORT);
                }
              }

              client.stop();
              tx_counter = 0;
              memset(tx_buffer, 0, sizeof(tx_buffer));
            }
          }
          else
          {
            Serial.print(".");
          }
        }
      }
    }
  }
}
